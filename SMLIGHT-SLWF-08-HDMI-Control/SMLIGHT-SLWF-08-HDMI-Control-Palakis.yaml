substitutions:
  name: "hdmi-control-palakis"
  friendly_name: "HDMI Control - palakis"
  project_name: "SMLIGHT.SLWF-08-HDMI"
  project_version: "1.0-Palakis"

esphome:
  name: "${name}"
  friendly_name: "${friendly_name}"
  name_add_mac_suffix: true
  project:
    name: "${project_name}"
    version: "${project_version}"

esp8266:
  board: esp12e

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: True
  # Enable fallback hotspot (captive portal) in case wifi connection fails
  #manual_ip:
  #  static_ip: 192.168.178.67
  #  gateway: 192.168.178.1
  #  subnet: 255.255.255.0
  ap:
    ssid: "HDMI-AP"
    password: !secret esphome_ota_password

mqtt:
  broker: '192.168.178.6' # insert IP or DNS of your own MQTT broker (e.g. the IP of your HA server)
  username: !secret mqtt_user # make sure your MQTT username is added to the secrets file in the ESPHome Add-on
  password: !secret mqtt_password # make sure your MQTT password is added to the secrets file in the ESPHome Add-on
  discovery: true # if you only want your own MQTT topics

captive_portal:

# Enable Home Assistant API
api:
  encryption:
    key: !secret esphome_hdmi_encryption_key
  services:
    - service: hdmi_cec_send
      variables:
        cec_source: int
        cec_destination: int
        cec_data: int[]
      then:
        - hdmi_cec.send:
            source: !lambda "return static_cast<unsigned char>(cec_source);"
            destination: !lambda "return static_cast<unsigned char>(cec_destination);"
            data: !lambda "std::vector<unsigned char> charVector; for (int i : cec_data) { charVector.push_back(static_cast<unsigned char>(i)); } return charVector;"

ota:
  - platform: esphome
    password: !secret esphome_ota_password

web_server:
  port: 80

# Enable logging
logger:

external_components:
#  - source: github://johnboiles/esphome-hdmi-cec
  - source: github://Palakis/esphome-hdmi-cec

dashboard_import:
  package_import_url: github://Schmackos/Home-Assistant/blob/main/SMLIGHT-SLWF-08-HDMI-Control/SMLIGHT-SLWF-08-HDMI-Control-Palakis.yaml

hdmi_cec:
  # Pick a GPIO pin that can do both input AND output
  pin: GPIO14
  # The address can be anything you want. Use 0xF if you only want to listen to the bus and not act like a standard device
  address: 0x05
  # Physical address of the device. In this case: 4.0.0.0 (HDMI4 on the TV)
  # DDC support is not yet implemented, so you'll have to set this manually.
  physical_address: 0x4000
  # The name that will be displayed in the list of devices on your TV/receiver
  osd_name: "SLWF-08-HDMI" # Optional. Defaults to "esphome"
  # By default, promiscuous mode is disabled, so the component only handles directly-address messages (matching
  # the address configured above) and broadcast messages. Enabling promiscuous mode will make the component
  # listen for all messages (both in logs and the on_message triggers)
  promiscuous_mode: false # Optional. Defaults to false
  # By default, monitor mode is disabled, so the component can send messages and acknowledge incoming messages.
  # Enabling monitor mode lets the component act as a passive listener, disabling active manipulation of the CEC bus.
  monitor_mode: false # Optional. Defaults to false  
  on_message:
    - opcode: 0x36 # opcode for "Standby"
      then:
        logger.log: "Got Standby command"
        # Respond to "Menu Request" (not required, example purposes only)
    - opcode: 0x8D
      then:
        hdmi_cec.send:
          # both "destination" and "data" are templatable
          destination: !lambda return source;
          data: [0x8E, 0x01] # 0x01 => "Menu Deactivated" 

    # Send CEC messages as Home Assistant events
    - then:
        - homeassistant.event:
            event: esphome.hdmi_cec # Home Assistant event type (visible in Developer Tools → Events)
            data:
              source: !lambda 'return source;'        # Logical address of the device that sent the message
              destination: !lambda 'return destination;'  # Logical address of the target device
              opcode: !lambda 'return data.size() ? data[0] : 0;'  # First byte of data = command opcode
              raw: !lambda 'return hdmi_cec::Frame(source, destination, data).to_string(true);'  # Full frame in hex (e.g. "40:36")
              translated: !lambda 'return hdmi_cec::Frame(source, destination, data).to_string();'  # Human-readable form (e.g. "TV → Broadcast: Standby")

    # Send CEC messages via MQTT in CEC-O-Matic format
    - then:
        - mqtt.publish:
            topic: cec_messages
            payload: !lambda |-
              return hdmi_cec::Frame(source, destination, data).to_string(true);

    # Publish decoded CEC messages as text sensors (raw and translated)
    - then:
        - lambda: |-
            hdmi_cec::Frame frame = hdmi_cec::Frame(source, destination, data);
            id(cec_raw_message).publish_state(frame.to_string(true));
            id(cec_translated_message).publish_state(frame.to_string());

text_sensor: #Consider excluding these sensors from your Home Assistant database to save space.
  - platform: template
    name: "HDMI CEC Raw Message"
    id: cec_raw_message #Do not delete if used with CEC message decoder
    update_interval: never

  - platform: template
    name: "HDMI CEC Translated Message"
    id: cec_translated_message #Do not delete if used with CEC message decoder
    update_interval: never

button:
  - platform: template
    name: "Turn all HDMI devices on"
    on_press:
      - hdmi_cec.send:
          destination: 0xF # or 0xF for Broadcast
          data: [0x04] # "Image View on

  - platform: template
    name: "Turn all HDMI devices off"
    on_press:
      - hdmi_cec.send:
          destination: 0xF
          data: [0x36] # "Standby" opcode

  - platform: template
    name: "Turn TV off"
    on_press:
      hdmi_cec.send:
        source: 1
        destination: 0
        data: [0x36]

  - platform: template
    name: "Turn TV on"
    on_press:
      hdmi_cec.send:
        source: 1
        destination: 0
        data: [0x04]

  - platform: template
    name: "Turn active source"
    on_press:
      - hdmi_cec.send:
          destination: 0xF # Broadcast
          data: [0x82] # "Power on" opcode

  - platform: template
    name: "Mute"
    on_press:
      - hdmi_cec.send:
          destination: 0xF # Broadcast
          data: [0x43] # "Mute" opcode          

  - platform: template
    name: "Volume Down"
    on_press:
      - hdmi_cec.send:
          destination: 0xF # Broadcast
          data: [0x42] # "Volume Down" opcode                   

  - platform: template
    name: "Volume Up"
    on_press:
      - hdmi_cec.send:
          destination: 0xF # Broadcast
          data: [0x41] # "Volume up" opcode

  - platform: template
    name: "Volume Receiver Up"
    on_press:
      hdmi_cec.send:
        destination: 0x5  # Usually the Audio System
        data: [0x44, 0x41]

  - platform: template
    name: "Volume Receiver Down"
    on_press:
      hdmi_cec.send:
        destination: 0x5  # Usually the Audio System
        data: [0x44, 0x42]

  # --- Playback Device 1 (Apple TV example) ---
  - platform: template
    name: "Turn on Playback device 1"
    on_press:
      hdmi_cec.send:
        destination: 4     # Typical address for first playback device (Apple TV)
        data: [0x44, 0x6D] # "Power On Function" / "Play"

  - platform: template
    name: "Turn off Playback device 1"
    on_press:
      hdmi_cec.send:
        destination: 4
        data: [0x36]       # "Standby"

  # --- Playback Device 2 (PlayStation 4 example) ---
  - platform: template
    name: "Turn on Playback device 2"
    on_press:
      hdmi_cec.send:
        destination: 8     # Typical address for second playback device (PS4)
        data: [0x44, 0x6D] # May vary depending on firmware

  - platform: template
    name: "Turn off Playback device 2"
    on_press:
      hdmi_cec.send:
        destination: 8
        data: [0x36]

  - platform: template
    name: "Playback 2 Play/Pause"
    on_press:
      hdmi_cec.send:
        destination: 8
        data: [0x44, 0x46]
